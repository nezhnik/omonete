# Изображения монет: хранение и оптимизация

## Сейчас

- В БД: **`catalog_number`** и отдельные столбцы для картинок:
  - **`image_obverse`**, **`image_reverse`** — аверс и реверс (путь или URL).
  - **`image_box`**, **`image_certificate`** — коробка и сертификат (показываем на сайте, если заданы).
- **Путь vs URL:** в столбцах храним либо **относительный путь** на нашем сайте (например `/image/coins/5109-0128-obverse.webp` — файл лежит в `public/image/coins/`), либо **полный URL** (например ЦБ). Для фронта в обоих случаях подставляем значение в `src` как есть.
- Если своего пути/URL нет, API подставляет URL ЦБ по `catalog_number` (аверс/реверс).

---

## Как хранить и оптимизировать без потери качества

### 1. Формат

- **WebP** (quality 85–90) — хороший баланс размера и качества, поддержка браузерами широкая.
- **AVIF** — ещё меньше размер при том же качестве, но кодирование дольше; можно отдавать по `Accept` тем, кто умеет.

### 2. Размеры (responsive)

Не отдавать одну огромную картинку везде:

- **Миниатюра** (каталог, серия): 200–300 px по длинной стороне.
- **Карточка/превью**: 400–500 px.
- **Детальная страница**: 800–1200 px или оригинал для zoom.

Так уменьшается трафик и время загрузки без видимой потери качества на экране.

### 3. Варианты хранения

| Вариант | Плюсы | Минусы |
|--------|--------|--------|
| **Только URL ЦБ (как сейчас)** | Ничего не храним, быстро внедрить | Зависимость от ЦБ, нет оптимизации |
| **Скачать и положить у себя** | Контроль, можно отдавать WebP/размеры | Нужен диск/CDN, скрипт загрузки |
| **Прокси/резайз на лету** | Один оригинал, размеры по запросу | Нужен сервис (sharp, imgix, Cloudinary и т.п.) |

### 4. Практичный путь

1. **Сейчас** — оставить подстановку URL ЦБ по `catalog_number` (уже сделано).
2. **Дальше** — скрипт, который по `catalog_number` качает с cbr.ru и сохраняет у себя (например в `public/coins/{catalog_number}.jpg` или в хранилище). В БД в `image_urls` писать уже свои URL.
3. **Оптимизация** — при сохранении генерировать 2–3 размера (thumb, card, full), лучше в WebP. Можно через **sharp** (Node) в скрипте или при загрузке; либо отдавать оригинал, а ресайз делать через API/CDN по параметру (width/height).

Итого: хранить у себя 1 файл на монету (или аверс+реверс), при обработке делать несколько размеров в WebP — это даёт и контроль качества, и уменьшение размера без видимой потери.
